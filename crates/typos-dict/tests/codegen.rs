#[test]
fn codegen() {
    const DICT: &[u8] = include_bytes!("../assets/words.csv");

    let mut trie_content = vec![];
    generate_trie(&mut trie_content, "WORD", DICT);
    let trie_content = String::from_utf8(trie_content).unwrap();
    let trie_content = codegenrs::rustfmt(&trie_content, None).unwrap();
    snapbox::assert_data_eq!(
        &trie_content,
        snapbox::file!["../benches/benches/trie_codegen.rs"].raw()
    );

    let mut map_content = vec![];
    generate_map(&mut map_content, "WORD", DICT);
    let map_content = String::from_utf8(map_content).unwrap();
    let map_content = codegenrs::rustfmt(&map_content, None).unwrap();
    snapbox::assert_data_eq!(
        &map_content,
        snapbox::file!["../benches/benches/map_codegen.rs"].raw()
    );

    let mut cased_map_content = vec![];
    generate_cased_map(&mut cased_map_content, "WORD", DICT);
    let cased_map_content = String::from_utf8(cased_map_content).unwrap();
    let cased_map_content = codegenrs::rustfmt(&cased_map_content, None).unwrap();
    snapbox::assert_data_eq!(
        &cased_map_content,
        snapbox::file!["../benches/benches/cased_map_codegen.rs"].raw()
    );

    let mut ordered_map_content = vec![];
    generate_ordered_map(&mut ordered_map_content, "WORD", DICT);
    let ordered_map_content = String::from_utf8(ordered_map_content).unwrap();
    let ordered_map_content = codegenrs::rustfmt(&ordered_map_content, None).unwrap();
    snapbox::assert_data_eq!(
        &ordered_map_content,
        snapbox::file!["../benches/benches/ordered_map_codegen.rs"].raw()
    );

    let mut aho_corasick_content = vec![];
    generate_aho_corasick(&mut aho_corasick_content, "Word", DICT);
    let aho_corasick_content = String::from_utf8(aho_corasick_content).unwrap();
    let aho_corasick_content = codegenrs::rustfmt(&aho_corasick_content, None).unwrap();
    snapbox::assert_data_eq!(
        &aho_corasick_content,
        snapbox::file!["../benches/benches/aho_corasick_codegen.rs"].raw()
    );

    snapbox::assert_data_eq!(&map_content, snapbox::file!["../src/word_codegen.rs"].raw());
}

fn generate_trie<W: std::io::Write>(file: &mut W, name: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file, "#![allow(unreachable_pub)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::DictGen::new()
        .name(name)
        .value_type("&[&str]")
        .trie()
        .write(
            file,
            records.iter().map(|record| {
                let mut record_fields = record.iter();
                let key = record_fields.next().unwrap();
                let value = format!(
                    "&[{}]",
                    itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
                );
                (key, value)
            }),
        )
        .unwrap();
}

fn generate_cased_map<W: std::io::Write>(file: &mut W, name: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file, "#![allow(unreachable_pub)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::DictGen::new()
        .name(&format!("{name}_ASCII_LOWER"))
        .value_type("&[&str]")
        .map()
        .unicase(false)
        .write(
            file,
            records
                .iter()
                .filter(|r| r.iter().next().unwrap().is_ascii())
                .map(|record| {
                    let mut record_fields = record.iter();
                    let key = record_fields.next().unwrap();
                    let value = format!(
                        "&[{}]",
                        itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
                    );
                    (key, value)
                }),
        )
        .unwrap();
    dictgen::DictGen::new()
        .name(&format!("{name}_ASCII_UPPER"))
        .value_type("&[&str]")
        .map()
        .unicase(false)
        .write(
            file,
            records
                .iter()
                .filter(|r| r.iter().next().unwrap().is_ascii())
                .map(|record| {
                    use heck::ToShoutySnakeCase;
                    let mut record_fields = record.iter();
                    let key = record_fields.next().unwrap().to_shouty_snake_case();
                    let value = format!(
                        "&[{}]",
                        itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
                    );
                    (key, value)
                }),
        )
        .unwrap();
    dictgen::DictGen::new()
        .name(&format!("{name}_ASCII_TITLE"))
        .value_type("&[&str]")
        .map()
        .unicase(false)
        .write(
            file,
            records
                .iter()
                .filter(|r| r.iter().next().unwrap().is_ascii())
                .map(|record| {
                    use heck::ToTitleCase;
                    let mut record_fields = record.iter();
                    let key = record_fields.next().unwrap().to_title_case();
                    let value = format!(
                        "&[{}]",
                        itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
                    );
                    (key, value)
                }),
        )
        .unwrap();
    dictgen::DictGen::new()
        .name(&format!("{name}_UNICODE"))
        .value_type("&[&str]")
        .ordered_map()
        .write(
            file,
            records
                .iter()
                .filter(|r| !r.iter().next().unwrap().is_ascii())
                .map(|record| {
                    let mut record_fields = record.iter();
                    let key = record_fields.next().unwrap();
                    let value = format!(
                        "&[{}]",
                        itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
                    );
                    (key, value)
                }),
        )
        .unwrap();
}

fn generate_map<W: std::io::Write>(file: &mut W, name: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file, "#![allow(unreachable_pub)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::DictGen::new()
        .name(name)
        .value_type("&[&str]")
        .map()
        .write(
            file,
            records.iter().map(|record| {
                let mut record_fields = record.iter();
                let key = record_fields.next().unwrap();
                let value = format!(
                    "&[{}]",
                    itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
                );
                (key, value)
            }),
        )
        .unwrap();
}

fn generate_ordered_map<W: std::io::Write>(file: &mut W, name: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file, "#![allow(unreachable_pub)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::DictGen::new()
        .name(name)
        .value_type("&[&str]")
        .ordered_map()
        .write(
            file,
            records.iter().map(|record| {
                let mut record_fields = record.iter();
                let key = record_fields.next().unwrap();
                let value = format!(
                    "&[{}]",
                    itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
                );
                (key, value)
            }),
        )
        .unwrap();
}

fn generate_aho_corasick<W: std::io::Write>(file: &mut W, name: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file, "#![allow(clippy::redundant_static_lifetimes)]",).unwrap();
    writeln!(file, "#![allow(unreachable_pub)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::DictGen::new()
        .name(name)
        .value_type("&'static [&'static str]")
        .aho_corasick()
        .write(
            file,
            records.iter().map(|record| {
                let mut record_fields = record.iter();
                let key = record_fields.next().unwrap();
                let value = format!(
                    "&[{}]",
                    itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
                );
                (key, value)
            }),
        )
        .unwrap();
}
